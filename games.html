<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Game - DD-Games Money</title>
    <style>
        /* CSS styles (Final Version) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #121212;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* Stop scrollbars */
            /* Background Image */
            background-image: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT0P4l4azF5XCuejb9u8t7PPnHfEGItqZNZMA&s');
            background-size: cover;
            background-position: center;
        }
        .container {
            background-color: rgba(30, 30, 30, 0.9); /* Semi-transparent background */
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            width: 90vw;
            max-width: 600px; /* Game එකට වැඩි ඉඩක් */
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .container h1 {
            margin-top: 0;
            color: #ffc107;
        }
        
        /* Game styles */
        #game-container {
            width: 100%;
            height: 400px; /* Game Canvas එකේ උස */
            background-color: #000;
            margin-top: 1rem;
            border-radius: 8px;
            overflow: hidden;
            display: none; /* --- මුලින් සඟවා තබයි --- */
            position: relative; /* Score එක උඩින් පෙන්වීමට */
        }
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffc107;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
        }
        
        /* Game Over Screen */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            /* (Final Fix) display: none; වෙනුවට flex; සහ visibility: hidden; */
            display: flex; 
            visibility: hidden; /* Hide by default */
            opacity: 0; /* Start invisible */
            transition: opacity 0.5s ease; /* Fade-in effect */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 20;
            font-size: 3rem;
            font-weight: bold;
            color: #f44336;
            text-shadow: 2px 2px 8px #000;
        }
        #game-over-screen small {
            font-size: 1.2rem;
            color: #fff;
            margin-top: 10px;
        }
        
        .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 4px; background-color: #007bff; color: white; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s; margin: 0.5rem; }
        .btn:hover { background-color: #0069d9; }
        .btn-nav { background-color: #6c757d; }
        .btn-nav:hover { background-color: #5a6268; }
        .btn-girl { background-color: #e91e63; } /* Pink for girl */
        .btn-girl:hover { background-color: #c2185b; }
        
        #message { margin-top: 1rem; font-size: 1.1rem; font-weight: bold; min-height: 20px; }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
    </style>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Tone.js Library (ශබ්ද සඳහා) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>
    <div class="container">
        <!-- Character Selection UI -->
        <div id="character-select">
            <h1>Endless Runner Game</h1>
            <p>Your Tickets: <strong id="ticket-count">Loading...</strong></p>
            <h3>Select Your Character</h3>
            <button id="select-boy" class="btn">Play as Boy (Blue)</button>
            <button id="select-girl" class="btn btn-girl">Play as Girl (Pink)</button>
            <div id="message"></div>
            <button id="wallet-btn" class="btn btn-nav" style="margin-top: 20px;">Go to Wallet</button>
        </div>

        <!-- The Actual Game Area -->
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <div id="score-display">Score: 0</div>
            <!-- Game Over Screen -->
            <div id="game-over-screen">
                GAME OVER
                <small id="game-over-score"></small>
            </div>
        </div>
    </div>

    <script>
        // --- 1. Global Variables & Auth ---
        const token = localStorage.getItem('ddUserToken');
        const authHeaders = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        };
        
        // Element cache
        const messageEl = document.getElementById('message');
        const ticketCountEl = document.getElementById('ticket-count');
        const gameContainerEl = document.getElementById('game-container');
        const scoreDisplayEl = document.getElementById('score-display').firstChild;
        const walletBtn = document.getElementById('wallet-btn');
        
        const characterSelectEl = document.getElementById('character-select');
        const selectBoyBtn = document.getElementById('select-boy');
        const selectGirlBtn = document.getElementById('select-girl');
        const gameOverScreenEl = document.getElementById('game-over-screen');
        const gameOverScoreEl = document.getElementById('game-over-score');

        let currentGameScore = 0;
        let isGameOver = false;
        let playerColor = '#007bff'; // Default to Boy (Blue)

        // Sound variables
        let bgMusic, gameOverSound;
        let soundInitialized = false;

        // --- 2. Initial Data Load & Sound Setup ---
        window.addEventListener('DOMContentLoaded', async () => {
            if (!token) { window.location.href = '/login.html'; return; }
            
            // Setup Sounds (but don't start)
            bgMusic = new Tone.Loop(time => {
                const synth = new Tone.Synth().toDestination();
                synth.triggerAttackRelease("C2", "8n", time);
                synth.triggerAttackRelease("G2", "8n", time + 0.5);
            }, "1n");
            
            gameOverSound = new Tone.Synth().toDestination();
            
            // Fetch user data
            try {
                const response = await fetch('/api/user-data', {
                    method: 'GET', headers: authHeaders
                });
                if (response.ok) {
                    const data = await response.json();
                    ticketCountEl.textContent = data.tickets;
                } else {
                    localStorage.removeItem('ddUserToken');
                    window.location.href = '/login.html';
                }
            } catch (error) { console.error('Error fetching user data:', error); }
        });

        // --- 3. Character Selection ---
        selectBoyBtn.addEventListener('click', () => {
            playerColor = '#007bff'; // Blue
            spendTicketAndStartGame();
        });
        selectGirlBtn.addEventListener('click', () => {
            playerColor = '#e91e63'; // Pink
            spendTicketAndStartGame();
        });

        // --- 4. Spend Ticket & Start Game ---
        async function spendTicketAndStartGame() {
            // (Final Fix) Start Tone.js on the *first user interaction*
            if (!soundInitialized) {
                await Tone.start();
                soundInitialized = true;
            }
            
            messageEl.textContent = 'Spending 1 ticket...';
            
            try {
                const response = await fetch('/api/spend-ticket', {
                    method: 'POST', headers: authHeaders
                });
                const data = await response.json();

                if (response.ok) {
                    messageEl.className = 'success';
                    messageEl.textContent = data.message;
                    ticketCountEl.textContent = data.newTicketCount;
                    
                    // --- Start the game ---
                    startGame();
                } else {
                    messageEl.className = 'error';
                    messageEl.textContent = `Error: ${data.message}`;
                }
            } catch (error) {
                messageEl.className = 'error';
                messageEl.textContent = 'Could not connect to the server.';
            }
        }

        // --- 5. Start Game Function ---
        function startGame() {
            currentGameScore = 0;
            isGameOver = false;
            gameSpeed = 0.05; // Reset game speed
            scoreDisplayEl.textContent = 'Score: 0';
            
            characterSelectEl.style.display = 'none'; // Hide character select
            gameContainerEl.style.display = 'block'; // <<<--- Show Game
            gameOverScreenEl.style.visibility = 'hidden'; // Hide Game Over screen
            gameOverScreenEl.style.opacity = 0;
            messageEl.textContent = ''; // Clear message
            
            // (Final Fix) Use requestAnimationFrame to wait for the next frame
            // This ensures the browser has rendered the 'gameContainerEl'
            // and it has a valid width/height *before* init3DGame is called.
            requestAnimationFrame(() => {
                init3DGame(playerColor); // <<<--- Start 3D Game Logic
            });
            
            // Start sounds
            Tone.Transport.start();
            bgMusic.start(0);
        }

        // --- 6. Go to Wallet Button ---
        walletBtn.addEventListener('click', () => {
            window.location.href = '/wallet.html';
        });

        // --- 7. Game Over Logic ---
        function triggerGameOver() {
            if (isGameOver) return; // Only trigger once
            isGameOver = true;
            
            // Stop game and music
            bgMusic.stop();
            Tone.Transport.stop();
            
            // Play game over sound
            gameOverSound.triggerAttackRelease("C3", "0.5s");
            gameOverSound.triggerAttackRelease("G2", "0.5s", "+0.1s");
            gameOverSound.triggerAttackRelease("C2", "1s", "+0.2s");
            
            // Show Game Over screen
            gameOverScoreEl.textContent = `Final Score: ${currentGameScore}`;
            gameOverScreenEl.style.visibility = 'visible';
            gameOverScreenEl.style.opacity = 1;
            
            // Post score to wallet
            if (currentGameScore > 0) {
                postScoreToWallet(currentGameScore);
            } else {
                 messageEl.textContent = 'Game Over!';
            }

            // Return to character select after 3 seconds
            setTimeout(() => {
                characterSelectEl.style.display = 'block';
                gameContainerEl.style.display = 'none';
                // (Final Fix) Don't reload, just reset UI
                // window.location.reload(); 
            }, 3000);
        }

        // --- 8. Post Score to Wallet ---
        async function postScoreToWallet(score) {
            messageEl.className = 'success';
            messageEl.textContent = `Game Over! Adding ${score} coins to your wallet balance...`;

            try {
                // Use /api/reload to add score (coins) to balance
                const response = await fetch('/api/reload', {
                    method: 'POST',
                    headers: authHeaders,
                    body: JSON.stringify({ amount: score }) // Send final score
                });
                const data = await response.json();

                if (response.ok) {
                    gameOverScoreEl.textContent = `Final Score: ${score}. Added to wallet!`;
                    messageEl.textContent = `Successfully added ${score} coins to your balance.`;
                } else {
                    messageEl.textContent = `Error: ${data.message}`;
                }
            } catch (error) {
                messageEl.className = 'error';
                messageEl.textContent = 'Could not save score to wallet.';
            }
        }


        // ******************************************************
        // --- 9. THREE.JS 3D GAME LOGIC (Final Fix) ---
        // ******************************************************
        let scene, camera, renderer, player, lanes, obstacles, coins, laneMarkers, buildings;
        const lanePositions = [-2, 0, 2]; // Lanes: Left, Center, Right
        let currentLane = 1; // Start in center

        function init3DGame(selectedPlayerColor) {
            // Clear previous game (if any)
            if (renderer) {
                renderer.dispose();
                scene.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
            }
            
            // (Final Fix) Get dimensions directly from the container
            const canvas = document.getElementById('game-canvas');
            const rect = gameContainerEl.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            if (width === 0 || height === 0) {
                console.error("Game container has no size. Cannot render 3D scene.");
                return; 
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2a); // Dark blue night sky
            scene.fog = new THREE.Fog(0x1a1a2a, 10, 30); // Fog for atmosphere
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 1.5, 4); // Positioned slightly up and back
            camera.lookAt(0, 1, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(width, height);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(2, 5, 5);
            scene.add(dirLight);
            
            // Player's "headlight"
            const headLight = new THREE.SpotLight(0xffffff, 1, 20, Math.PI / 4, 0.5);
            headLight.position.set(0, 0.5, 3.5); // Just in front of player
            
            // Highway Road
            const groundGeo = new THREE.PlaneGeometry(10, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); // Dark grey asphalt
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            scene.add(ground);
            
            // Lane Markers
            laneMarkers = [];
            const markerGeo = new THREE.PlaneGeometry(0.2, 3);
            const markerMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            for (let z = 0; z > -100; z -= 6) {
                const marker1 = new THREE.Mesh(markerGeo, markerMat);
                marker1.rotation.x = -Math.PI / 2;
                marker1.position.set(-1, -0.49, z);
                scene.add(marker1);
                laneMarkers.push(marker1);
                const marker2 = new THREE.Mesh(markerGeo, markerMat);
                marker2.rotation.x = -Math.PI / 2;
                marker2.position.set(1, -0.49, z);
                scene.add(marker2);
                laneMarkers.push(marker2);
            }
            
            // City Buildings (Background)
            buildings = [];
            const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
            for(let i = 0; i < 50; i++) {
                const height = Math.random() * 15 + 5;
                const mat = new THREE.MeshStandardMaterial({ color: 0x555555 }); // Dark buildings
                const building = new THREE.Mesh(buildingGeo, mat);
                building.scale.set(Math.random() * 2 + 1, height, Math.random() * 2 + 1);
                building.position.set((Math.random() > 0.5 ? 1 : -1) * (Math.random() * 10 + 6), height / 2 - 0.5, -(Math.random() * 100));
                scene.add(building);
                buildings.push(building);
            }

            // Player (Boy/Girl Box)
            const playerGeo = new THREE.BoxGeometry(0.6, 1.2, 0.6); // Character shape
            const playerMat = new THREE.MeshStandardMaterial({ color: selectedPlayerColor });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.y = 0.1; // Slightly above ground
            player.position.z = 3; // Start in front of camera
            player.position.x = lanePositions[currentLane];
            scene.add(player);
            headLight.target = player; // Headlight follows player
            scene.add(headLight);

            // Obstacles and Coins
            obstacles = [];
            coins = [];
            for (let i = -10; i > -300; i -= (Math.random() * 10 + 8)) { // Spawn objects
                 const rand = Math.random();
                 if (rand < 0.7) {
                     spawnCoin(i); // 70% chance of coin
                 } else {
                     spawnObstacle(i); // 30% chance of obstacle
                 }
            }

            // Add Key controls
            document.removeEventListener('keydown', handleKeyPress); // Remove old listener
            document.addEventListener('keydown', handleKeyPress); // Add new one

            // Start animation loop
            animate();
        }

        // --- 10. Spawn Functions ---
        function spawnObstacle(zPos) {
            const lane = Math.floor(Math.random() * 3); // Random lane
            const isCar = Math.random() > 0.4; // 60% car, 40% truck
            const geo = isCar ? 
                new THREE.BoxGeometry(1.6, 0.8, 2.5) : // Car shape
                new THREE.BoxGeometry(1.8, 1.8, 3.5); // Truck shape
            const mat = new THREE.MeshStandardMaterial({ color: isCar ? 0xf44336 : 0x607d8b }); // Red Car / Grey Truck
            const obstacle = new THREE.Mesh(geo, mat);
            obstacle.position.set(lanePositions[lane], isCar ? -0.1 : 0.4, zPos);
            obstacles.push(obstacle);
            scene.add(obstacle);
        }
        function spawnCoin(zPos) {
             const lane = Math.floor(Math.random() * 3); // Random lane
             const geo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16); // Bitcoin shape
             const mat = new THREE.MeshStandardMaterial({ color: 0xffc107 }); // Gold color
             const coin = new THREE.Mesh(geo, mat);
             coin.rotation.x = Math.PI / 2; // Lay flat
             coin.rotation.z = Math.PI / 2; // Align with road
             coin.position.set(lanePositions[lane], 0, zPos);
             coins.push(coin);
             scene.add(coin);
        }

        // --- 11. Key Input ---
        function handleKeyPress(event) {
            if (isGameOver) return;
            if (event.key === 'ArrowLeft') {
                if (currentLane > 0) {
                    currentLane--;
                }
            } else if (event.key === 'ArrowRight') {
                if (currentLane < 2) {
                    currentLane++;
                }
            }
        }
        
        // --- 12. Collision Detection ---
        function checkCollision(obj) {
            if (!player) return false; // Safety check
            const playerBox = new THREE.Box3().setFromObject(player);
            const objBox = new THREE.Box3().setFromObject(obj);
            return playerBox.intersectsBox(objBox);
        }

        // --- 13. Animation Loop ---
        function animate() {
            if (isGameOver) {
                // (Final Fix) Stop the animation loop
                renderer.setAnimationLoop(null); 
                return;
            }
            
            // (Final Fix) Ensure renderer exists before looping
            if (!renderer) return; 
            renderer.setAnimationLoop(animate); // Use setAnimationLoop

            // Smooth player movement
            player.position.x += (lanePositions[currentLane] - player.position.x) * 0.15; // Faster lerp
            
            // Difficulty scaling
            // Score 0-79: 0.05
            // Score 80-159: 0.051
            // Score 160-239: 0.052
            gameSpeed = 0.05 + (Math.floor(currentGameScore / 80) * 0.001);

            // Move road markers
            laneMarkers.forEach(marker => {
                marker.position.z += gameSpeed;
                if(marker.position.z > 5) {
                    marker.position.z = -100; // Reset to back
                }
            });
            
            // Move buildings (slower for parallax)
             buildings.forEach(b => {
                b.position.z += gameSpeed * 0.5; 
                if(b.position.z > 5) {
                    b.position.z = -100;
                }
            });

            // Move Obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.position.z += gameSpeed;
                // Collision check (only when close)
                if (obstacle.position.z > 2.5 && obstacle.position.z < 3.5 && checkCollision(obstacle)) {
                    triggerGameOver();
                }
                // Respawn
                if (obstacle.position.z > camera.position.z + 2) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                    spawnObstacle(-100); // Spawn a new one
                }
            });

            // Move Coins
            coins.forEach((coin, index) => {
                coin.position.z += gameSpeed;
                coin.rotation.z += 0.1; // Spin coin
                
                // Collision check (only when close)
                if (coin.position.z > 2.5 && coin.position.z < 3.5 && checkCollision(coin)) {
                    currentGameScore += 1; // 1 coin = +1
                    scoreDisplayEl.textContent = 'Score: ' + currentGameScore;
                    scene.remove(coin);
                    coins.splice(index, 1);
                    // (No win condition at 1000)
                }
                
                // Respawn
                if (coin.position.z > camera.position.z + 2) {
                    scene.remove(coin);
                    coins.splice(index, 1);
                    spawnCoin(-100); // Spawn a new one
                }
            });
            
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
